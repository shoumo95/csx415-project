---
title: "Model Performance - linear"
author:
  - name: Hakan Egeli
  - name: Soumyendu Sarkar
date: 'April 24, 2018'
knit: (function(inputFile, encoding) { 
      rmarkdown::render(inputFile,
                        encoding=encoding, 
                        output_file=file.path(dirname(inputFile), '../reports/', 'model-performance-metrics.html')) })
output: html_document
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, root.dir = "..")
```


```{r, echo=FALSE, include = FALSE}

cwd <- getwd()

# load the project. This will autoload the data and also create training and test datasets
setwd("..")
library('ProjectTemplate')
load.project()

setwd(cwd)

```

```{r, echo=FALSE}

library(nnet)

```

```{r, echo=FALSE}

# optional parallelism to be used by caret's trainControl 
library(doParallel);

cl <- makeCluster(detectCores())
registerDoParallel(cl)

```

# Model After Backward Elimitaion Process

## Regression Models

```{r, echo=FALSE, warning=FALSE}

control <- trainControl(method="repeatedcv", number=5, repeats=1)

model_glm_naive <- train(CreditLimit ~ SalesLastYr, data=dataset_train, method="glm", metric="RMSE", trControl=control)

```

```{r, echo=FALSE, warning=FALSE}

control <- trainControl(method="repeatedcv", number=5, repeats=1)

model_glm_int <- train(CreditLimit ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds, data=dataset_train, method="glm", metric="RMSE", trControl=control)

```

```{r, echo=FALSE, warning=FALSE}

model_glm <- train(CreditLimit ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="glm", metric="RMSE", trControl=control)

```


```{r, echo=FALSE, warning=FALSE}

metric.regression.create <- function(){
  setNames(data.frame(matrix(ncol = 4, nrow = 0)), c("RMSE", "RMSESD", "Rsquared", "RsquaredSD"))
}

metric.regression.append <- function(df, model, row_name){
  df_tmp <- metric.regression.create()
  df_tmp <- bind_rows(df_tmp, c(RMSE=mean(model$resample[["RMSE"]]),
                                RMSESD=sd(model$resample[["RMSE"]]),
                                Rsquared=mean(model$resample[["Rsquared"]]),
                                RsquaredSD=sd(model$resample[["Rsquared"]])))
  rownames(df_tmp) <- c(row_name)
  rbind(df, df_tmp)
}

df <- metric.regression.create()
df <- metric.regression.append(df, model_glm_naive, "glm naive")
df <- metric.regression.append(df, model_glm_int, "glm w/ intercept")
df <- metric.regression.append(df, model_glm, "glm w/o intercept")

df

```

## Regression Tests Accuracy

```{r, warning=FALSE}

predictions <- predict(model_glm, newdata=dataset_test)
postResample(dataset_test$CreditLimit, predictions)

```


## Classification Models
```{r, echo=FALSE, warning=FALSE}

control <- trainControl(method="repeatedcv", number=5, repeats=2, classProbs=TRUE, allowParallel=TRUE)

```

```{r, echo=FALSE, warning=FALSE}

model_steplda <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="stepLDA", metric="Accuracy", trControl=control, trace=FALSE)

```

```{r, echo=FALSE, warning=FALSE}

model_svmRad <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="svmRadial", metric="Accuracy", trControl=control)

```

```{r, echo=FALSE, warning=FALSE}

#model_bag <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="bag", metric="Accuracy", preProc=c("center", "scale"), trControl=control)

```

```{r, echo=FALSE, warning=FALSE}

model_rpart <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="rpart", metric="Accuracy", trControl=control)

```

```{r, echo=FALSE, warning=FALSE}

model_rpart2 <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="rpart2", metric="Accuracy", trControl=control)

```

```{r, echo=FALSE, warning=FALSE}

model_rf <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="rf", metric="Accuracy", trControl=control, tuneGrid=data.frame(.mtry=19))

```

```{r, echo=FALSE, warning=FALSE}

model_multinom <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="multinom", metric="Accuracy", trControl=control, maxit=600, trace=FALSE)

```

```{r, echo=FALSE, warning=FALSE}

model_avNNet <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="avNNet", metric="Accuracy", trControl=control, maxit=600, trace=FALSE)

```

```{r, echo=FALSE, warning=FALSE}

model_nnet <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="nnet", trControl=control, tuneGrid=data.frame(.size=20, .decay=1.0e-1), rang=0.1, maxit=10000, trace=FALSE)

```


```{r, echo=FALSE, warning=FALSE}

metric.classification.create <- function(){
  setNames(data.frame(matrix(ncol = 4, nrow = 0)), c("Accuracy", "AccuracySD", "Kappa", "KappaSD"))
}

metric.classification.append <- function(df, model, row_name){
  df_tmp <- metric.classification.create()
  df_tmp <- bind_rows(df_tmp, c(Accuracy=mean(model$resample[["Accuracy"]]),
                                AccuracySD=sd(model$resample[["Accuracy"]]),
                                Kappa=mean(model$resample[["Kappa"]]),
                                KappaSD=sd(model$resample[["Kappa"]])))
  rownames(df_tmp) <- c(row_name)
  rbind(df, df_tmp)
}

df <- metric.classification.create()
df <- metric.classification.append(df, model_rpart, "rpart")
df <- metric.classification.append(df, model_rpart2, "rpart2")
df <- metric.classification.append(df, model_rf, "rf")
df <- metric.classification.append(df, model_multinom, "multi")
df <- metric.classification.append(df, model_avNNet, "avNNet")
df <- metric.classification.append(df, model_nnet, "nnet")
df <- metric.classification.append(df, model_steplda, "steplda")
df <- metric.classification.append(df, model_svmRad, "svmRad")

df

```

## Classification Test Accuracy

```{r, warning=FALSE}

predictions <- predict(model_rf, newdata=dataset_test)
postResample(dataset_test$CreditLimitCategory, predictions)
cm <- confusionMatrix(data=table(predictions, dataset_test$CreditLimitCategory))
cm$overall

```

```{r, warning=FALSE}

predictions <- predict(model_nnet, newdata=dataset_test)
postResample(dataset_test$CreditLimitCategory, predictions)
cm <- confusionMatrix(data=table(predictions, dataset_test$CreditLimitCategory))
cm$overall

```

## Winner

```{r, echo=FALSE, warning=FALSE}

model_rf <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset, method="rf", metric="Accuracy", tuneGrid=data.frame(.mtry=19))

```


```{r, echo=FALSE, warning=FALSE}

model_rf$results

```

```{r, echo=FALSE}

# save the model as a file to be used in the model package
saveRDS(model_rf, "../data/final_model.rds")

# save the test data to be included in the model package
save(dataset_test, file = "../data/creditlimittestdata.rda")

```

```{r, echo=FALSE}

require(caret)
# we now replaced the below line with a package
# model_loaded <- readRDS("../data/final_model.rds")
library(CreditLimitModel)
data("creditlimittestdata")

# getCreditModel is in the CreditLimitModel package
model_loaded <- getCreditModel()

predictions <- predict(model_loaded, newdata=dataset_test)
cm <- confusionMatrix(data=table(predictions, dataset_test$CreditLimitCategory))
cm

```

```{r, echo=FALSE}

stopCluster(cl)

```
