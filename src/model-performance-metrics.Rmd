---
title: "Model Performance - metrics"
author:
  - name: Hakan Egeli
  - name: Soumyendu Sarkar
date: 'April 24, 2018'
knit: (function(inputFile, encoding) { 
      rmarkdown::render(inputFile,
                        encoding=encoding, 
                        output_file=file.path(dirname(inputFile), '../reports/', 'model-performance-metrics.html')) })
output: html_document
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, root.dir = "..")
```


```{r, echo=FALSE, include = FALSE}

cwd <- getwd()

# load the project. This will autoload the data and also create training and test datasets
setwd("..")
library('ProjectTemplate')
load.project()

setwd(cwd)

```

```{r, echo=FALSE}

# for multinom and nnet methods
library(nnet)

```

```{r, echo=FALSE, warning=FALSE, message=FALSE}

# optional parallelism to be used by caret's trainControl 
library(doParallel);

cl <- makeCluster(detectCores())
registerDoParallel(cl)

```

# Model After Backward Elimitaion Process

## Regression Models

```{r, echo=FALSE, warning=FALSE}

control <- trainControl(method="repeatedcv", number=5, repeats=1)

```

```{r, echo=FALSE, warning=FALSE}

# generalized linear naive model only using the Sales Last Year
model_glm_naive <- train(CreditLimit ~ SalesLastYr, data=dataset_train, method="glm", metric="RMSE", trControl=control)

```

```{r, echo=FALSE, warning=FALSE}

# generalized linear model with the significant independent variables, with the intercept
model_glm_int <- train(CreditLimit ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds, data=dataset_train, method="glm", metric="RMSE", trControl=control)

```

```{r, echo=FALSE, warning=FALSE}

# generalized linear model with the significant independent variables, without the intercept
model_glm <- train(CreditLimit ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="glm", metric="RMSE", trControl=control)

```

Comparison of linear models using the RMSE and $R^2$ with their respective standard deviations.

```{r, echo=FALSE, warning=FALSE}

metric.regression.create <- function(){
  setNames(data.frame(matrix(ncol = 4, nrow = 0)), c("RMSE", "RMSESD", "Rsquared", "RsquaredSD"))
}

metric.regression.append <- function(df, model, row_name){
  df_tmp <- metric.regression.create()
  df_tmp <- bind_rows(df_tmp, c(RMSE=mean(model$resample[["RMSE"]]),
                                RMSESD=sd(model$resample[["RMSE"]]),
                                Rsquared=mean(model$resample[["Rsquared"]]),
                                RsquaredSD=sd(model$resample[["Rsquared"]])))
  rownames(df_tmp) <- c(row_name)
  rbind(df, df_tmp)
}

df <- metric.regression.create()
df <- metric.regression.append(df, model_glm_naive, "glm naive")
df <- metric.regression.append(df, model_glm_int, "glm w/ intercept")
df <- metric.regression.append(df, model_glm, "glm w/o intercept")

df

```

## Regression Tests Accuracy

RMSE, $R^2$ and MAE results using the test dataset.

```{r, warning=FALSE}

predictions <- predict(model_glm, newdata=dataset_test)
postResample(dataset_test$CreditLimit, predictions)

```

## Classification Models

```{r, echo=FALSE, warning=FALSE}

control <- trainControl(method="repeatedcv", number=5, repeats=2, classProbs=TRUE, allowParallel=TRUE)

```

```{r, echo=FALSE, warning=FALSE}

model_naive <- train(CreditLimitCategory ~ SalesLastYr, data=dataset_train, method="rpart", metric="Accuracy", trControl=control)

```

```{r, echo=FALSE, warning=FALSE}

model_rpart <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="rpart", metric="Accuracy", trControl=control)

```

```{r, echo=FALSE, warning=FALSE}

model_rpart2 <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="rpart2", metric="Accuracy", trControl=control)

```

```{r, echo=FALSE, warning=FALSE, message=FALSE}

model_steplda <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="stepLDA", metric="Accuracy", trControl=control, trace=FALSE)

```

```{r, echo=FALSE, warning=FALSE}

model_svmLinear <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="svmLinear", metric="Accuracy", trControl=control)

```

```{r, echo=FALSE, warning=FALSE}

model_svmRad <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="svmRadial", metric="Accuracy", trControl=control)

```

```{r, echo=FALSE, warning=FALSE}

model_svmPoly <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="svmPoly", metric="Accuracy", trControl=control)

```

```{r, echo=FALSE, warning=FALSE}

model_rf <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="rf", metric="Accuracy", trControl=control, tuneGrid=data.frame(.mtry=19))

```

```{r, echo=FALSE, warning=FALSE}

model_multinom <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="multinom", metric="Accuracy", trControl=control, maxit=600, trace=FALSE)

```

```{r, echo=FALSE, warning=FALSE}

model_avNNet <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="avNNet", metric="Accuracy", trControl=control, maxit=600, trace=FALSE)

```

```{r, echo=FALSE, warning=FALSE}

model_nnet <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset_train, method="nnet", trControl=control, tuneGrid=data.frame(.size=20, .decay=1.0e-1), rang=0.1, maxit=10000, trace=FALSE)

```


```{r, echo=FALSE, warning=FALSE}

metric.classification.create <- function(){
  setNames(data.frame(matrix(ncol = 4, nrow = 0)), c("Accuracy", "AccuracySD", "Kappa", "KappaSD"))
}

metric.classification.append <- function(df, model, row_name){
  df_tmp <- metric.classification.create()
  df_tmp <- bind_rows(df_tmp, c(Accuracy=mean(model$resample[["Accuracy"]]),
                                AccuracySD=sd(model$resample[["Accuracy"]]),
                                Kappa=mean(model$resample[["Kappa"]]),
                                KappaSD=sd(model$resample[["Kappa"]])))
  rownames(df_tmp) <- c(row_name)
  rbind(df, df_tmp)
}

df <- metric.classification.create()
df <- metric.classification.append(df, model_naive, "naive")
df <- metric.classification.append(df, model_rpart, "rpart")
df <- metric.classification.append(df, model_rpart2, "rpart2")
df <- metric.classification.append(df, model_rf, "rf")
df <- metric.classification.append(df, model_multinom, "multi")
df <- metric.classification.append(df, model_avNNet, "avNNet")
df <- metric.classification.append(df, model_nnet, "nnet")
df <- metric.classification.append(df, model_steplda, "steplda")
df <- metric.classification.append(df, model_svmLinear, "svmLinear")
df <- metric.classification.append(df, model_svmRad, "svmRad")
df <- metric.classification.append(df, model_svmPoly, "svmPoly")

df[with(df, order(-Accuracy)),]

```

After comparing our Naive version of our classification model to other models that we built using Decision Tree (**rpart** and **raprt2**), Random Forest (**rf**), Multinomial Log-linear Model via Neural Networks (**multinom**), Single-hidden-layer Neural Network (**nnet**), Neural Networks Using Model Averaging (**avNNet**), Linear Discriminant Analysis with Stepwise Feature Selection (**stepLDA**), Support Vector Machines with Radial Basis Function Kernel (**svmRad**) we found that the Random Forest model was the one with the best Accuracy and the highest Kappa value. The second best model was Multinomial Log-liner model. So, we cheched these two models against the test data to evaluate their metric.

## Classification Test Accuracy

Random Rorest model against the test data:

```{r, warning=FALSE}

predictions <- predict(model_rf, newdata=dataset_test)
postResample(dataset_test$CreditLimitCategory, predictions)
cm <- confusionMatrix(data=table(predictions, dataset_test$CreditLimitCategory))
cm$overall

```

Multinomial Log-liner model against the test data:

```{r, warning=FALSE}

predictions <- predict(model_nnet, newdata=dataset_test)
postResample(dataset_test$CreditLimitCategory, predictions)
cm <- confusionMatrix(data=table(predictions, dataset_test$CreditLimitCategory))
cm$overall

```

## Final model

From the last two model tests, we have confirmed that the model built using the random forest was the one with the best accuracy and bet Kappa value.

We re-trainned the model using the entire dataset in order to save this model and create a package.

```{r}

model_rf <- train(CreditLimitCategory ~ JBTRating + CreditLimitLocked + SalesCurrentYr + SalesLastYr + DesignBandSalesLast12Mo + NumberOfStoreLocations + AvgDaysOfPayCategory + ReturnedPaymentCount + RuralUrbanContinuumCode + MetroIndicator + MedianEarnings + MedianIncomeHouseholds - 1, data=dataset, method="rf", metric="Accuracy", tuneGrid=data.frame(.mtry=19))

```


```{r, echo=FALSE, warning=FALSE}

model_rf$results

```

```{r, echo=FALSE, include=FALSE}

# save the model as a file to be used in the model package
#saveRDS(model_rf, "../data/final_model.rds")

# save the test data to be included in the model package
#save(dataset_test, file = "../data/creditlimittestdata.rda")

```

```{r, echo=FALSE, include=FALSE}

require(caret)
require(randomForest)
# we now replaced the below line with a package
# model_loaded <- readRDS("../data/final_model.rds")

# install.packages("./pkgs/CreditLimitModel", repos = NULL, type = "source")
library(CreditLimitModel)
data("creditlimittestdata")


# getCreditModel is in the CreditLimitModel package
model_loaded <- getCreditModel()

predictions <- predict(model_loaded, newdata=dataset_test)
cm <- confusionMatrix(data=table(predictions, dataset_test$CreditLimitCategory))
cm

```

```{r, echo=FALSE}

stopCluster(cl)

```
